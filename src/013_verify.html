<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script src="https://bundle.run/buffer@6.0.3"></script>
  <script type="module">
    // @see https://www.npmjs.com/package/symbol-sdk?activeTab=versions
    const SDK_VERSION = "3.1.0";
    const symbolSdk = (
      await import(
        `https://www.unpkg.com/symbol-sdk@${SDK_VERSION}/dist/bundle.web.js`
      )
    ).default;

    const sha3_256 = (await import("https://cdn.skypack.dev/@noble/hashes/sha3")).sha3_256;

    const NODE = 'https://001-sai-dual.symboltest.net:3001';
    const Buffer = buffer.Buffer;
    let networkType, generationHash, epochAdjustment, identifier, facade;
    fetch(new URL("/node/info", NODE), {
      method: "GET",
      headers: { "Content-Type": "application/json" },
    })
      .then((res) => res.json())
      .then((json) => {
        networkType = json.networkIdentifier;
        generationHash = json.networkGenerationHashSeed;
      });

    fetch(new URL("/network/properties", NODE), {
      method: "GET",
      headers: { "Content-Type": "application/json" },
    })
      .then((res) => res.json())
      .then((json) => {
        const e = json.network.epochAdjustment;
        epochAdjustment = Number(e.substring(0, e.length - 1));
        identifier = json.network.identifier; // v3 only
        facade = new symbolSdk.facade.SymbolFacade(identifier); // v3 only
      });

    // 葉のハッシュ値取得関数
    function getLeafHash(encodedPath, leafValue) {
      const hasher = sha3_256.create();
      return symbolSdk.utils.uint8ToHex(
        hasher.update(symbolSdk.utils.hexToUint8(encodedPath + leafValue)).digest(),
      );
    }

    // 枝のハッシュ値取得関数
    function getBranchHash(encodedPath, links) {
      const branchLinks = Array(16).fill(
        symbolSdk.utils.uint8ToHex(new Uint8Array(32)),
      );
      links.forEach((link) => {
        branchLinks[parseInt(`0x${link.bit}`, 16)] = link.link;
      });
      const hasher = sha3_256.create();
      const bHash = symbolSdk.utils.uint8ToHex(
        hasher
          .update(symbolSdk.utils.hexToUint8(encodedPath + branchLinks.join("")))
          .digest(),
      );
      return bHash;
    }

    // ワールドステートの検証
    function checkState(stateProof, stateHash, pathHash, rootHash) {
      let merkleLeaf = undefined;
      let merkleBranches = [];
      stateProof.tree.forEach((n) => {
        if (n.type === 255) {
          merkleLeaf = n;
        } else {
          merkleBranches.push(n);
        }
      });
      merkleBranches.reverse();

      const leafHash = getLeafHash(merkleLeaf.encodedPath, stateHash);

      let linkHash = leafHash; // 最初のlinkHashはleafHash
      let bit = "";
      for (let i = 0; i < merkleBranches.length; i++) {
        const branch = merkleBranches[i];
        const branchLink = branch.links.find((x) => x.link === linkHash);
        linkHash = getBranchHash(branch.encodedPath, branch.links);
        bit =
          merkleBranches[i].path.slice(0, merkleBranches[i].nibbleCount) +
          branchLink.bit +
          bit;
      }

      const treeRootHash = linkHash; // 最後のlinkHashはrootHash
      let treePathHash = bit + merkleLeaf.path;

      if (treePathHash.length % 2 == 1) {
        treePathHash = treePathHash.slice(0, -1);
      }

      // 検証
      console.log(treeRootHash === rootHash);
      console.log(treePathHash === pathHash);
    }

    const aliceAddress = new symbolSdk.symbol.Address(
      "TBIL6D6RURP45YQRWV6Q7YVWIIPLQGLZQFHWFEQ",
    );

    let hasher = sha3_256.create();
    const alicePathHash = symbolSdk.utils.uint8ToHex(
      hasher.update(aliceAddress.bytes).digest(),
    );

    hasher = sha3_256.create();
    const aliceInfo = await fetch(new URL("/accounts/" + aliceAddress.toString(), NODE), {
      method: "GET",
      headers: { "Content-Type": "application/json" },
    })
      .then((res) => res.json())
      .then((json) => {
        return json.account;
      });

    // アカウント情報から StateHash を導出
    // catbuffer-typescript が使える場合はそちらを利用すると楽
    let format =
      parseInt(aliceInfo.importance) === 0 || aliceInfo.activityBuckets.length < 5
        ? 0x00
        : 0x01;
    const supplementalPublicKeysMask = 0x00;
    let linkedPublicKey = new Uint8Array([]);
    if (aliceInfo.supplementalPublicKeys.linked !== undefined) {
      supplementalPublicKeysMask |= 0x01;
      linkedPublicKey = symbolSdk.utils.hexToUint8(
        aliceInfo.supplementalPublicKeys.linked.publicKey,
      );
    }
    let nodePublicKey = new Uint8Array([]);
    if (aliceInfo.supplementalPublicKeys.node !== undefined) {
      supplementalPublicKeysMask |= 0x02;
      nodePublicKey = symbolSdk.utils.hexToUint8(
        aliceInfo.supplementalPublicKeys.node.publicKey,
      );
    }
    let vrfPublicKey = new Uint8Array([]);
    if (aliceInfo.supplementalPublicKeys.vrf !== undefined) {
      supplementalPublicKeysMask |= 0x04;
      vrfPublicKey = symbolSdk.utils.hexToUint8(
        aliceInfo.supplementalPublicKeys.vrf.publicKey,
      );
    }
    let votingPublicKeys = new Uint8Array([]);
    if (aliceInfo.supplementalPublicKeys.voting !== undefined) {
      aliceInfo.supplementalPublicKeys.voting.publicKeys.forEach((key) => {
        votingPublicKeys = new Uint8Array([
          ...votingPublicKeys,
          ...symbolSdk.utils.hexToUint8(key.publicKey),
        ]);
      });
    }
    let importanceSnapshots = new Uint8Array([]);
    if (parseInt(aliceInfo.importance) !== 0) {
      importanceSnapshots = new Uint8Array([
        ...Buffer.from(
          BigInt(aliceInfo.importance)
            .toString(16)
            .padStart(8 * 2, "0"),
          "hex",
        ).reverse(),
        ...Buffer.from(
          BigInt(aliceInfo.importanceHeight)
            .toString(16)
            .padStart(8 * 2, "0"),
          "hex",
        ).reverse(),
      ]);
    }
    let activityBuckets = new Uint8Array([]);
    if (aliceInfo.importance > 0) {
      for (let idx = 0; idx < aliceInfo.activityBuckets.length || idx < 5; idx++) {
        const bucket = aliceInfo.activityBuckets[idx];
        activityBuckets = new Uint8Array([
          ...activityBuckets,
          ...Buffer.from(
            BigInt(bucket.startHeight)
              .toString(16)
              .padStart(8 * 2, "0"),
            "hex",
          ).reverse(),
          ...Buffer.from(
            BigInt(bucket.totalFeesPaid)
              .toString(16)
              .padStart(8 * 2, "0"),
            "hex",
          ).reverse(),
          ...Buffer.from(
            bucket.beneficiaryCount.toString(16).padStart(4 * 2, "0"),
            "hex",
          ).reverse(),
          ...Buffer.from(
            BigInt(bucket.rawScore)
              .toString(16)
              .padStart(8 * 2, "0"),
            "hex",
          ).reverse(),
        ]);
      }
    }
    let balances = new Uint8Array([]);
    if (aliceInfo.mosaics.length > 0) {
      aliceInfo.mosaics.forEach((mosaic) => {
        balances = new Uint8Array([
          ...balances,
          ...symbolSdk.utils.hexToUint8(mosaic.id).reverse(),
          ...Buffer.from(
            BigInt(mosaic.amount)
              .toString(16)
              .padStart(8 * 2, "0"),
            "hex",
          ).reverse(),
        ]);
      });
    }
    let accountInfoBytes = new Uint8Array([
      ...Buffer.from(
        aliceInfo.version.toString(16).padStart(2 * 2, "0"),
        "hex",
      ).reverse(),
      ...symbolSdk.utils.hexToUint8(aliceInfo.address),
      ...Buffer.from(
        BigInt(aliceInfo.addressHeight)
          .toString(16)
          .padStart(8 * 2, "0"),
        "hex",
      ).reverse(),
      ...symbolSdk.utils.hexToUint8(aliceInfo.publicKey),
      ...Buffer.from(
        BigInt(aliceInfo.publicKeyHeight)
          .toString(16)
          .padStart(8 * 2, "0"),
        "hex",
      ).reverse(),
      ...Buffer.from(
        aliceInfo.accountType.toString(16).padStart(1 * 2, "0"),
        "hex",
      ).reverse(),
      ...Buffer.from(format.toString(16).padStart(1 * 2, "0"), "hex").reverse(),
      ...Buffer.from(
        supplementalPublicKeysMask.toString(16).padStart(1 * 2, "0"),
        "hex",
      ).reverse(),
      ...Buffer.from(
        votingPublicKeys.length.toString(16).padStart(1 * 2, "0"),
        "hex",
      ).reverse(),
      ...linkedPublicKey,
      ...nodePublicKey,
      ...vrfPublicKey,
      ...votingPublicKeys,
      ...importanceSnapshots,
      ...activityBuckets,
      ...Buffer.from(
        aliceInfo.mosaics.length.toString(16).padStart(2 * 2, "0"),
        "hex",
      ).reverse(),
      ...balances,
    ]);
    const aliceStateHash = symbolSdk.utils.uint8ToHex(
      hasher.update(accountInfoBytes).digest(),
    );

    // サービス提供者以外のノードから最新のブロックヘッダー情報を取得
    const query = new URLSearchParams({
      order: "desc",
    });
    const blockInfo = await fetch(new URL("/blocks?" + query.toString(), NODE), {
      method: "GET",
      headers: { "Content-Type": "application/json" },
    })
      .then((res) => res.json())
      .then((json) => {
        return json;
      });
    const rootHash = blockInfo.data[0].meta.stateHashSubCacheMerkleRoots[0];

    // サービス提供者を含む任意のノードからマークル情報を取得
    const stateProof = await fetch(
      new URL("/accounts/" + aliceAddress.toString() + "/merkle", NODE),
      {
        method: "GET",
        headers: { "Content-Type": "application/json" },
      },
    )
      .then((res) => res.json())
      .then((json) => {
        return json;
      });

    // 検証
    checkState(stateProof, aliceStateHash, alicePathHash, rootHash);
  </script>
</body>
</html>
